esphome:
  name: m5atom-advantage-air
  friendly_name: Zone 6 Sniffer

esp32:
  board: m5stack-atom
  variant: ESP32
  framework:
    type: arduino

logger:
  baud_rate: 115200
  level: INFO

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

uart:
  id: rs485_bus
  tx_pin: GPIO19
  rx_pin: GPIO22
  baud_rate: 57600
  data_bits: 8
  stop_bits: 1
  parity: NONE
  debug:
    direction: RX
    dummy_receiver: true
    after:
      timeout: 500ms
    sequence:
      - lambda: |-
          std::string data;
          for (auto c : bytes) {
            if (c >= 32 && c < 127) data += static_cast<char>(c);
          }
          id(response_buffer) += data;

          size_t pos;
          while ((pos = id(response_buffer).find("</iZS10.3>")) != std::string::npos) {
            std::string response = id(response_buffer).substr(0, pos + 10);
            id(response_buffer) = id(response_buffer).substr(pos + 10);

            ESP_LOGI("AC", "RX: %s", response.c_str());

            if (response.find("<request>setZoneData</request>") != std::string::npos) {
              int zone_id = 0;
              auto zone_start = response.find("<zone");
              if (zone_start != std::string::npos) {
                for (int i = 0; i < 20 && zone_start + i < response.size(); i++) {
                  char c = response[zone_start + i];
                  if (c >= '0' && c <= '9') {
                    zone_id = c - '0';
                    break;
                  }
                  if (c == '>') break;
                }
              }

              ESP_LOGI("AC", "=== SET Zone %d ===", zone_id);
              
              // Extract and log ALL tags between <request> and </request>
              size_t tag_start = zone_start;
              while (tag_start < response.size() && tag_start != std::string::npos) {
                if (response[tag_start] != '<') {
                  tag_start++;
                  continue;
                }
                size_t tag_end = response.find(">", tag_start);
                if (tag_end == std::string::npos) break;
                
                std::string tag = response.substr(tag_start + 1, tag_end - tag_start - 1);
                
                // Skip tags that are just numbers or structural
                if (!tag.empty() && tag[0] != '/' && tag.find("request") == std::string::npos && 
                    tag.find("zone") == std::string::npos && tag.find("iZS") == std::string::npos) {
                  auto value_start = response.find("<" + tag + ">");
                  if (value_start != std::string::npos && value_start < response.size()) {
                    auto value_end = response.find("</" + tag + ">", value_start);
                    if (value_end != std::string::npos && value_end < response.size()) {
                      std::string value = response.substr(value_start + tag.size() + 2, value_end - value_start - tag.size() - 2);
                      ESP_LOGI("AC", "  %s: %s", tag.c_str(), value.c_str());
                    }
                  }
                }
                tag_start = tag_end + 1;
              }
            }

            if (response.find("<request>setSystemData</request>") != std::string::npos) {
              ESP_LOGI("AC", "=== SET SYSTEM ===");
              
              // Extract and log ALL tags between <request> and </request>
              size_t tag_start = response.find("<request>setSystemData</request>");
              if (tag_start != std::string::npos) {
                tag_start += 24; // Skip past <request>setSystemData</request>
              }
              
              while (tag_start < response.size() && tag_start != std::string::npos) {
                if (response[tag_start] != '<') {
                  tag_start++;
                  continue;
                }
                size_t tag_end = response.find(">", tag_start);
                if (tag_end == std::string::npos) break;
                
                std::string tag = response.substr(tag_start + 1, tag_end - tag_start - 1);
                
                // Skip tags that are just structural
                if (!tag.empty() && tag[0] != '/' && tag.find("request") == std::string::npos && 
                    tag.find("iZS") == std::string::npos) {
                  auto value_start = response.find("<" + tag + ">");
                  if (value_start != std::string::npos && value_start < response.size()) {
                    auto value_end = response.find("</" + tag + ">", value_start);
                    if (value_end != std::string::npos && value_end < response.size()) {
                      std::string value = response.substr(value_start + tag.size() + 2, value_end - value_start - tag.size() - 2);
                      ESP_LOGI("AC", "  %s: %s", tag.c_str(), value.c_str());
                    }
                  }
                }
                tag_start = tag_end + 1;
              }
            }
          }

globals:
  - id: response_buffer
    type: std::string
    initial_value: '""'
